// Generated by CoffeeScript 1.10.0
(function() {
  var Evernote, MIME_TO_EXTESION_MAPPING, Note, Sync, SyncStatus, Tags, async, cheerio, client, eqArr, exec, fs, getImgRes, noteStore, uniq;

  Evernote = require('evernote').Evernote;

  async = require('async');

  exec = require('child_process').exec;

  fs = require('fs');

  client = require('../servers/ervernote');

  noteStore = client.getNoteStore('https://app.yinxiang.com/shard/s5/notestore');

  Note = require('../models/note');

  Tags = require('../models/tags');

  SyncStatus = require('../models/sync_status');

  uniq = require('uniq');

  cheerio = require('cheerio');

  eqArr = require('./help').eqArr;

  MIME_TO_EXTESION_MAPPING = {
    'image/png': '.png',
    'image/jpg': '.jpg',
    'image/jpeg': '.jpg',
    'image/gif': '.gif'
  };

  getImgRes = function(hashStr, minmeType, noteGuid, cb) {
    var pyFile;
    pyFile = __dirname + '/test.py';
    console.log(pyFile);
    return exec(("python " + pyFile + " ") + hashStr + ' ' + noteGuid, {
      maxBuffer: 1024 * 5000000
    }, function(err, stdout, stderr) {
      var img, writeRes;
      if (err) {
        return cb(err);
      }
      writeRes = 'public/images/' + hashStr + MIME_TO_EXTESION_MAPPING[minmeType];
      img = new Buffer(stdout, 'base64');
      fs.writeFileSync(writeRes, img);
      return cb();
    });
  };

  Sync = (function() {
    function Sync() {
      this.guid = 'bd6d5877-9ff8-400d-9d83-f6c4baeb2406';
      this.filterNote = new Evernote.NoteFilter();
      this.filterNote.notebookGuid = this.guid;
      this.reParams = new Evernote.NotesMetadataResultSpec();
      this.reParams.includeTitle = true;
      this.reParams.includeCreated = true;
      this.reParams.includeUpdated = true;
      this.reParams.includeDeleted = true;
      this.reParams.includeTagGuids = true;
      this.reParams.includeNotebookGuid = true;
    }

    Sync.prototype.getNoteList = function(cb) {
      var self;
      self = this;
      return noteStore.findNotesMetadata(self.filterNote, 0, 100, self.reParams, function(err, info) {
        if (err) {
          return cb(err);
        }
        console.log(info);
        console.log(info.totalNotes);
        console.log(info.notes.length);
        console.log(info.notes[0].tagGuids);
        return cb(null, info.notes);
      });
    };

    Sync.prototype.checkNote = function(noteList, CB) {
      var self;
      self = this;
      return async.eachSeries(noteList, function(item, cb) {
        return async.auto({
          A: function(callback) {
            return self.getContent(item, callback);
          },
          B: function(callback) {
            return self.findNote(item.guid, callback);
          },
          C: [
            'A', 'B', function(callback, rs) {
              var newContent, noteRow;
              noteRow = rs.B;
              newContent = rs.A;
              if (!noteRow) {
                console.log("[Create]");
                return self.createNote(item, newContent, callback);
              } else {
                console.log("[Update]");
                return self.updateNote(noteRow, item, newContent, callback);
              }
            }
          ]
        }, function(err) {
          if (err) {
            return console.log(err);
          }
          return cb();
        });
      }, function(eachErr) {
        if (eachErr) {
          return console.log(err);
        }
        return CB();
      });
    };

    Sync.prototype.getContent = function(note, cb) {
      console.log("getContent ==>", note.title);
      return noteStore.getNoteContent(note.guid, function(err, content) {
        if (err) {
          return cb(err);
        }
        return cb(null, content);
      });
    };

    Sync.prototype.findNote = function(noteGuid, cb) {
      return Note.findOne({
        guid: noteGuid
      }, function(err, note_row) {
        if (err) {
          return cb(err);
        }
        return cb(null, note_row);
      });
    };

    Sync.prototype.createNote = function(noteInfo, noteContent, cb) {
      var newNote, self;
      self = this;
      newNote = new Note();
      newNote.guid = noteInfo.guid;
      newNote.title = noteInfo.title;
      newNote.content = noteContent;
      newNote.created = noteInfo.created;
      newNote.updated = noteInfo.updated;
      newNote.tagGuids = noteInfo.tagGuids;
      newNote.notebookGuid = noteInfo.notebookGuid;
      return async.waterfall([
        function(callback) {
          return self.getTagName(newNote, callback);
        }, function(noteObj, callback) {
          return self.changeImgHtml(noteObj, callback);
        }
      ], function(err) {
        if (err) {
          return cb(err);
        }
        return cb();
      });
    };

    Sync.prototype.updateNote = function(noteRow, itemNote, newContent, cb) {
      var self;
      self = this;
      noteRow.title = itemNote.title;
      noteRow.content = newContent;
      noteRow.created = itemNote.created;
      noteRow.updated = itemNote.updated;
      noteRow.tagGuids = itemNote.tagGuids;
      noteRow.notebookGuid = itemNote.notebookGuid;
      return async.waterfall([
        function(callback) {
          return self.getTagName(noteRow, callback);
        }, function(noteObj, callback) {
          return self.changeImgHtml(noteObj, callback);
        }
      ], function(err) {
        if (err) {
          return cb(err);
        }
        return cb();
      });
    };

    Sync.prototype.changeImgHtml = function(note, cb) {

      /* 替换Img标签和下载资源 */
      var $, all_media;
      console.log("changeImgHtml ==>", note.title);
      $ = cheerio.load(note.content);
      all_media = $('en-media');
      return async.eachSeries(all_media, function(item, callback) {
        var hashStr, mimeType, newTag;
        hashStr = item.attribs.hash;
        mimeType = item.attribs.type;
        newTag = $("<img src=/images/" + (hashStr + MIME_TO_EXTESION_MAPPING[mimeType]) + ">");
        return getImgRes(hashStr, mimeType, note.guid, function(err) {
          if (err) {
            return callback(err);
          }
          $(item).replaceWith(newTag);
          return callback();
        });
      }, function(eachErr) {
        if (eachErr) {
          return cb(eachErr);
        }
        $("h3").remove();
        $("h2").remove();
        $("del").remove();
        note.htmlContent = $.html();
        return note.save(function(sErr, row) {
          if (sErr) {
            return cb(sErr);
          }
          return cb(null, row);
        });
      });
    };

    Sync.prototype.getTagName = function(note, cb) {

      /* 获取标签名 */
      return noteStore.getNoteTagNames(note.guid, function(err, tagsName) {
        if (err) {
          return cb(err);
        }
        if (!eqArr(note.tags, tagsName)) {
          note.tags = tagsName;
        }
        console.log("getTagName ==>", note.title);
        return cb(null, note);
      });
    };

    Sync.prototype.getAllNoteTag = function(cb) {
      var tagsList;
      tagsList = [];
      return Note.find({}, {
        'tags': 1
      }, function(err, tags) {
        var i, j, k, len, len1, ref, t;
        if (err) {
          return cb(err);
        }
        console.log("getAllNoteTag ==>", tags);
        for (j = 0, len = tags.length; j < len; j++) {
          i = tags[j];
          ref = i.tags;
          for (k = 0, len1 = ref.length; k < len1; k++) {
            t = ref[k];
            tagsList.push(t);
          }
        }
        return cb(null, tagsList);
      });
    };

    Sync.prototype.saveTags = function(cb) {
      var self;
      self = this;
      return async.waterfall([
        function(callback) {
          return self.getAllNoteTag(callback);
        }, function(tags, callback) {
          tags = uniq(tags);
          console.log("saveTags ==>", tags);
          return Tags.findOne(function(err, dbTags) {
            if (err) {
              return cb(err);
            }
            if (dbTags) {
              dbTags.tags = tags;
              dbTags.syncStatus = Date.parse(new Date());
            } else {
              dbTags = new Tags();
              dbTags.tags = tags;
              dbTags.syncStatus = Date.parse(new Date());
            }
            return dbTags.save(function(err1, row) {
              if (err1) {
                return cb(err1);
              }
              return cb(null, row);
            });
          });
        }
      ]);
    };

    Sync.prototype.doTask = function() {
      var self;
      self = this;
      return async.auto({
        A: function(cb) {
          return self.getNoteList(cb);
        },
        B: [
          'A', function(cb, noteList) {
            console.log(noteList);
            return self.checkNote(noteList.A, cb);
          }
        ],
        C: [
          'B', function(cb) {
            return self.saveTags(cb);
          }
        ]
      });
    };

    return Sync;

  })();

  module.exports = Sync;

}).call(this);

//# sourceMappingURL=sync3.js.map
